{"ast":null,"code":"import { DirectionalLight, Group, LightProbe, WebGLCubeRenderTarget } from 'three';\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession();\n\n    // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext();\n\n      // Ensure that we have any extensions needed to use the preferred cube map format.\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    }\n\n    // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n    session.requestAnimationFrame(this.frameCallback);\n  }\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n        this.xrLight.environment.needsPMREMUpdate = true;\n      }\n    }\n  }\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1.0;\n\n      // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n      const intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n}\nexport class XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight);\n\n    // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true;\n\n            // Fired to indicate that the estimated lighting values are now being updated.\n            this.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    });\n\n    // Done inline to provide access to sessionLightProbe.\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n}","map":{"version":3,"names":["DirectionalLight","Group","LightProbe","WebGLCubeRenderTarget","SessionLightProbe","constructor","xrLight","renderer","lightProbe","environmentEstimation","estimationStartCallback","xrWebGLBinding","frameCallback","onXRFrame","bind","session","xr","getSession","window","cubeRenderTarget","environment","texture","gl","getContext","preferredReflectionFormat","getExtension","XRWebGLBinding","addEventListener","updateReflection","requestAnimationFrame","textureProperties","properties","get","cubeMap","getReflectionCubeMap","__webglTexture","needsPMREMUpdate","time","xrFrame","lightEstimate","getLightEstimate","sh","fromArray","sphericalHarmonicsCoefficients","intensity","intensityScalar","Math","max","primaryLightIntensity","x","y","z","directionalLight","color","setRGB","position","copy","primaryLightDirection","dispose","XREstimatedLight","add","sessionLightProbe","estimationStarted","requestLightProbe","reflectionFormat","then","probe","dispatchEvent","type","remove"],"sources":["C:/Mahasiswa/New folder/Furniture/node_modules/three/examples/jsm/webxr/XREstimatedLight.js"],"sourcesContent":["import {\n\tDirectionalLight,\n\tGroup,\n\tLightProbe,\n\tWebGLCubeRenderTarget\n} from 'three';\n\nclass SessionLightProbe {\n\n\tconstructor( xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback ) {\n\n\t\tthis.xrLight = xrLight;\n\t\tthis.renderer = renderer;\n\t\tthis.lightProbe = lightProbe;\n\t\tthis.xrWebGLBinding = null;\n\t\tthis.estimationStartCallback = estimationStartCallback;\n\t\tthis.frameCallback = this.onXRFrame.bind( this );\n\n\t\tconst session = renderer.xr.getSession();\n\n\t\t// If the XRWebGLBinding class is available then we can also query an\n\t\t// estimated reflection cube map.\n\t\tif ( environmentEstimation && 'XRWebGLBinding' in window ) {\n\n\t\t\t// This is the simplest way I know of to initialize a WebGL cubemap in Three.\n\t\t\tconst cubeRenderTarget = new WebGLCubeRenderTarget( 16 );\n\t\t\txrLight.environment = cubeRenderTarget.texture;\n\n\t\t\tconst gl = renderer.getContext();\n\n\t\t\t// Ensure that we have any extensions needed to use the preferred cube map format.\n\t\t\tswitch ( session.preferredReflectionFormat ) {\n\n\t\t\t\tcase 'srgba8':\n\t\t\t\t\tgl.getExtension( 'EXT_sRGB' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rgba16f':\n\t\t\t\t\tgl.getExtension( 'OES_texture_half_float' );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.xrWebGLBinding = new XRWebGLBinding( session, gl );\n\n\t\t\tthis.lightProbe.addEventListener( 'reflectionchange', () => {\n\n\t\t\t\tthis.updateReflection();\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// Start monitoring the XR animation frame loop to look for lighting\n\t\t// estimation changes.\n\t\tsession.requestAnimationFrame( this.frameCallback );\n\n\t}\n\n\tupdateReflection() {\n\n\t\tconst textureProperties = this.renderer.properties.get( this.xrLight.environment );\n\n\t\tif ( textureProperties ) {\n\n\t\t\tconst cubeMap = this.xrWebGLBinding.getReflectionCubeMap( this.lightProbe );\n\n\t\t\tif ( cubeMap ) {\n\n\t\t\t\ttextureProperties.__webglTexture = cubeMap;\n\n\t\t\t\tthis.xrLight.environment.needsPMREMUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tonXRFrame( time, xrFrame ) {\n\n\t\t// If either this obejct or the XREstimatedLight has been destroyed, stop\n\t\t// running the frame loop.\n\t\tif ( ! this.xrLight ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst session = xrFrame.session;\n\t\tsession.requestAnimationFrame( this.frameCallback );\n\n\t\tconst lightEstimate = xrFrame.getLightEstimate( this.lightProbe );\n\t\tif ( lightEstimate ) {\n\n\t\t\t// We can copy the estimate's spherical harmonics array directly into the light probe.\n\t\t\tthis.xrLight.lightProbe.sh.fromArray( lightEstimate.sphericalHarmonicsCoefficients );\n\t\t\tthis.xrLight.lightProbe.intensity = 1.0;\n\n\t\t\t// For the directional light we have to normalize the color and set the scalar as the\n\t\t\t// intensity, since WebXR can return color values that exceed 1.0.\n\t\t\tconst intensityScalar = Math.max( 1.0,\n\t\t\t\tMath.max( lightEstimate.primaryLightIntensity.x,\n\t\t\t\t\tMath.max( lightEstimate.primaryLightIntensity.y,\n\t\t\t\t\t\tlightEstimate.primaryLightIntensity.z ) ) );\n\n\t\t\tthis.xrLight.directionalLight.color.setRGB(\n\t\t\t\tlightEstimate.primaryLightIntensity.x / intensityScalar,\n\t\t\t\tlightEstimate.primaryLightIntensity.y / intensityScalar,\n\t\t\t\tlightEstimate.primaryLightIntensity.z / intensityScalar );\n\t\t\tthis.xrLight.directionalLight.intensity = intensityScalar;\n\t\t\tthis.xrLight.directionalLight.position.copy( lightEstimate.primaryLightDirection );\n\n\t\t\tif ( this.estimationStartCallback ) {\n\n\t\t\t\tthis.estimationStartCallback();\n\t\t\t\tthis.estimationStartCallback = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.xrLight = null;\n\t\tthis.renderer = null;\n\t\tthis.lightProbe = null;\n\t\tthis.xrWebGLBinding = null;\n\n\t}\n\n}\n\nexport class XREstimatedLight extends Group {\n\n\tconstructor( renderer, environmentEstimation = true ) {\n\n\t\tsuper();\n\n\t\tthis.lightProbe = new LightProbe();\n\t\tthis.lightProbe.intensity = 0;\n\t\tthis.add( this.lightProbe );\n\n\t\tthis.directionalLight = new DirectionalLight();\n\t\tthis.directionalLight.intensity = 0;\n\t\tthis.add( this.directionalLight );\n\n\t\t// Will be set to a cube map in the SessionLightProbe is environment estimation is\n\t\t// available and requested.\n\t\tthis.environment = null;\n\n\t\tlet sessionLightProbe = null;\n\t\tlet estimationStarted = false;\n\t\trenderer.xr.addEventListener( 'sessionstart', () => {\n\n\t\t\tconst session = renderer.xr.getSession();\n\n\t\t\tif ( 'requestLightProbe' in session ) {\n\n\t\t\t\tsession.requestLightProbe( {\n\n\t\t\t\t\treflectionFormat: session.preferredReflectionFormat\n\n\t\t\t\t} ).then( ( probe ) => {\n\n\t\t\t\t\tsessionLightProbe = new SessionLightProbe( this, renderer, probe, environmentEstimation, () => {\n\n\t\t\t\t\t\testimationStarted = true;\n\n\t\t\t\t\t\t// Fired to indicate that the estimated lighting values are now being updated.\n\t\t\t\t\t\tthis.dispatchEvent( { type: 'estimationstart' } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\trenderer.xr.addEventListener( 'sessionend', () => {\n\n\t\t\tif ( sessionLightProbe ) {\n\n\t\t\t\tsessionLightProbe.dispose();\n\t\t\t\tsessionLightProbe = null;\n\n\t\t\t}\n\n\t\t\tif ( estimationStarted ) {\n\n\t\t\t\t// Fired to indicate that the estimated lighting values are no longer being updated.\n\t\t\t\tthis.dispatchEvent( { type: 'estimationend' } );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Done inline to provide access to sessionLightProbe.\n\t\tthis.dispose = () => {\n\n\t\t\tif ( sessionLightProbe ) {\n\n\t\t\t\tsessionLightProbe.dispose();\n\t\t\t\tsessionLightProbe = null;\n\n\t\t\t}\n\n\t\t\tthis.remove( this.lightProbe );\n\t\t\tthis.lightProbe = null;\n\n\t\t\tthis.remove( this.directionalLight );\n\t\t\tthis.directionalLight = null;\n\n\t\t\tthis.environment = null;\n\n\t\t};\n\n\t}\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}